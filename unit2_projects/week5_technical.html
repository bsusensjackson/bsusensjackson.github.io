<!DOCTYPE html>

<html>
<head>
	<title>bsusensjackson</title>
	<link rel="stylesheet" type="text/css" href="stylesheets/my_wireframe.css"/>
  <!--<link rel="stylesheet" type="text/css" href="reset.css" /> -->
  <link href='http://fonts.googleapis.com/css?family=Miss+Fajardose' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="../unit2_projects/font-awesome/css/font-awesome.min.css"/>

	</head>
<body>
	<header>brendan susens-jackson...</header>
  <nav>
    <ul>
      <li>HOME</li>
      <li>ABOUT</li>
      <li>PORTFOLIO</li>
      <li>CONTACT</li>
      <li>BLOG</li>
    </ul>
  </nav>
 
 <div id="main">
  <h1>5.4.14</h1>
  <h2>Organizing Objects With Classes in Ruby</h2>
  <p>As you may or may not be familiar with, Ruby is an Object Oriented programming language. But what does this mean, exactly?</p>

<p>In essence, Ruby does not divide behavior and data into two separate entities, instead, it combines the two into a single thing: an object.  Objects have behavior and may contain data, in which case they will control access to the data.  Objects invoke one another&#39;s behavior by sending each other messages.  In Ruby, every single object is an instance of some particular Class, and the way that the object will behave is determined more or less by the method definitions have been set up inside of that object&#39;s Class.  For example, every time that you write a new object of class &quot;string&quot;:</p> 
<p><span class ="code">>myString = String.new</span>
<br><span class = "code">>myString = &quot;This is my string. There are many like it, but this one is special.&quot;</span> </p>

<p>You are creating an object that is an instance of class String, that has certain innate characteristics, which are already built into the Ruby language.</p>

<p>The beauty of organizing your objects by making classes is that it gives your program scalability.  Instead of having to define behavior for every single object that you&#39;ve written, you can define behavior for that object&#39;s class. </p>

<p>Let&#39;s take a look at a simple way to divvy up arithmetic tasks via Ruby class &quot;calculator&quot;</p>

<span class ="code">
  >class Calculator
  <br>> def add(num_1, num_2)
  <br>>  num_1 + num_2
  <br>> end
  <br>
  <br>> def subtract(num_1, num_2)
  <br>>  num_1 - num_2
  <br>> end
<br>>end
<br>
<br>>calc = Calculator.new
<br>>puts calc.add(2, 3)
<br>>puts calc.subtract(5, 3)
</span>

<p>In this example, we are setting up a Calculator class and defining how we want it to behave given a set of particular input.  Instead of defining multiple behaviors in one method, we create greater program durability and malleability by dividing up the behaviors into separate methods.  Any new object that we create that is an instance of class Calculator (such as &quot;calc&quot; in the above example) will inherit these two methods.  We can have as many calculators as we want!</p>

 </div>
  <footer><p> Copyright 2014 || Brendan Susens-Jackson</p>
      <div class ="right">
      <ul>
        <li><a href="http://www.github.com/bsusensjackson" target="_blank"><i class="fa fa-github"></i></a></li>
        <li><a href="http://www.twitter.com/brendansjackson" target="_blank"><i class="fa fa-twitter"></i></a></li>
        <li><a href="http://www.linkedin.com/pub/brendan-susens-jackson/30/39/442" target="_blank"><i class="fa fa-linkedin-square"></i></a></li>
        <li><a href="https://plus.google.com/+BrendanSusensJackson" target="_blank"><i class="fa fa-google-plus"></i></a></li>
      </ul>
    </div>
    
   </footer>

</body></html>
